---
title: "Welcome to Polos"
description: "Durable execution platform for AI agents"
---

# Introduction

Polos is a **durable execution platform** for AI agents. It provides the stateful infrastructure required to run long-running, autonomous agents reliably at scale.

Write your logic in plain Python (or TypeScript - coming soon). Polos ensures it survives crashes, handles failures, and scales automatically.

## Why Polos?

Most AI agents work in demo but break in production. Agents are long-running distributed systems - yet we run them on infrastructure built for stateless APIs.

Polos gives you everything you need to build production-grade AI agents out of the box:

- **Durable execution**: Your agent survives server restarts and resumes exactly where it stopped, call stack and local variables intact. If a 20-step workflow crashes at step 18, Polos resumes from step 18 - no re-running the first 17 LLM calls, no wasted tokens. No manual checkpointing or retry logic needed.

- **Workflows**: Write workflows as plain async code. Call one function from another, handle errors with try/catch, use loops and conditionals - just regular code. Polos automatically makes it durable so your code survives crashes and resumes mid-execution.

- **Global concurrency control**: Control how many agents run simultaneously using queues with configurable concurrency limits. Prevent one workflow from exhausting your OpenAI quota or overloading external APIs. Only active executions count toward limits - queued runs wait their turn without consuming resources.

- **Human-in-the-loop**: Pause an agent mid-execution to await user approval, then resume hours or days later with full state intact. In serverless environments, paused agents consume zero compute - you only pay when they're actively running. Perfect for approval workflows, financial transactions, or any operation requiring human oversight.

- **Persistent memory**: Give your agents persistent context that survives across steps, servers, and execution lifetimes. Agents maintain conversation history, and  context automatically.

- **Agent coordination**: When building multi-agent systems, seamlessly hand off context and reasoning history between specialized agents. Shared working memory prevents state drift and enables true agent collaboration.

- **Decision-level observability**: Trace the reasoning and intent behind every tool call, not just raw logs. Built-in observability shows you why your agent chose Tool B over Tool A, making debugging deterministic failures in stochastic systems actually possible.

## What can you build?

If your agent runs for more than 30 seconds, it needs durable execution. Polos is designed for:

- **Long-running workflows** – Research bots or coding assistants that operate over minutes or hours

- **Human-in-the-loop** – Agents that pause execution for human approval and resume hours later with full state

- **Multi-agent systems** – Multi-agent systems that share working memory to coordinate complex tasks

- **Mission-critical automation** – Workflows that perform side effects (Stripe charges, DB writes) and require strict "exactly-once" semantics

## Next Steps

<CardGroup cols={3}>
  <Card
    title="Quickstart"
    icon="rocket"
    href="/quickstart"
  >
    Deploy your first durable agent in 5 minutes
  </Card>
  <Card
    title="Core Concepts"
    icon="lightbulb"
    href="/fundamentals/overview"
  >
    Learn how Polos handles state and durability
  </Card>
  <Card
    title="Examples"
    icon="book-open"
    href="/guides/cookbook-examples"
  >
    See how to build HITL agents and multi-agent systems
  </Card>
</CardGroup>
